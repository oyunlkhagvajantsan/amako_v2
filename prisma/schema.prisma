generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  username        String           @unique
  password        String
  role            Role             @default(USER)
  isSubscribed    Boolean          @default(false)
  subscriptionEnd DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  ageVerified     Boolean          @default(false)
  comments        Comment[]
  commentLikes    CommentLike[]
  likes           Like[]
  notifications   Notification[]
  paymentRequests PaymentRequest[]
  readHistory     ReadHistory[]
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  content   String
  link      String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Manga {
  id            Int         @id @default(autoincrement())
  title         String
  titleMn       String
  description   String?
  descriptionMn String?
  coverImage    String
  bannerImage   String?
  author        String?
  artist        String?
  publishYear   Int?
  status        MangaStatus @default(ONGOING)
  type          MangaType   @default(MANGA)
  viewCount     Int         @default(0)
  likeCount     Int         @default(0)
  featured      Boolean     @default(false)
  isPublished   Boolean     @default(false)
  isAdult       Boolean     @default(false)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  isOneshot     Boolean     @default(false)
  chapters      Chapter[]
  comments      Comment[]
  likes         Like[]
  genres        Genre[]     @relation("GenreToManga")
  deletedAt     DateTime?

  @@index([status])
  @@index([createdAt])
  @@index([viewCount])
}

model Chapter {
  id            Int           @id @default(autoincrement())
  mangaId       Int
  chapterNumber Float
  title         String?
  titleMn       String?
  images        String[]
  isFree        Boolean       @default(false)
  isPublished   Boolean       @default(false)
  viewCount     Int           @default(0)
  publishedAt   DateTime      @default(now())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  thumbnail     String?
  caption       String?
  manga         Manga         @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  comments      Comment[]
  readHistory   ReadHistory[]
  deletedAt     DateTime?

  @@unique([mangaId, chapterNumber])
  @@index([mangaId])
  @@index([publishedAt])
}

model Genre {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  nameMn    String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())
  mangas    Manga[]  @relation("GenreToManga")
}

model ReadHistory {
  id        String   @id @default(cuid())
  userId    String
  chapterId Int
  lastPage  Int      @default(0)
  completed Boolean  @default(false)
  readAt    DateTime @default(now())
  updatedAt DateTime @updatedAt
  chapter   Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, chapterId])
  @@index([userId])
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  mangaId   Int
  createdAt DateTime @default(now())
  manga     Manga    @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, mangaId])
  @@index([userId])
  @@index([mangaId])
}

model CommentLike {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  createdAt DateTime @default(now())
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@index([userId])
  @@index([commentId])
}

model Comment {
  id        String        @id @default(cuid())
  userId    String
  mangaId   Int
  content   String
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  isHidden  Boolean       @default(false)
  parentId  String?
  chapterId Int?
  chapter   Chapter?      @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  manga     Manga         @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  parent    Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("CommentReplies")
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes     CommentLike[]

  @@index([mangaId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
}

model PaymentRequest {
  id        String        @id @default(cuid())
  userId    String
  amount    Float
  months    Int           @default(1)
  imageUrl  String
  status    PaymentStatus @default(PENDING)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationCode {
  id        String           @id @default(cuid())
  email     String
  code      String
  type      VerificationType @default(RESET_PASSWORD)
  expiresAt DateTime
  createdAt DateTime         @default(now())

  @@index([email])
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

enum MangaStatus {
  ONGOING
  COMPLETED
  HIATUS
}

enum MangaType {
  MANGA
  MANHWA
  MANHUA
  ONESHOT
}

enum PaymentStatus {
  PENDING
  APPROVED
  REJECTED
}

enum VerificationType {
  RESET_PASSWORD
  EMAIL_VERIFICATION
}
